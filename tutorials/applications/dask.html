
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Using Dask and napari to process &amp; view large datasets &#8212; napari</title>
    
    <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
  
    
    <link rel="stylesheet"
      href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">
  
    
      
  
    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/pydata-sphinx-theme.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
    <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">
  
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Single cell tracking with napari" href="../tracking/cell_tracking.html" />
    <link rel="prev" title="Annotating videos with napari" href="annotate_points.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../index.html">
  <img src="../../_static/logo.png" class="logo" alt="logo">
</a>


    
    <!-- A small template snippet for theme testing -->
<b>napari</b>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="../../usage.html">
  Usage
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../plugins/index.html">
  Plugins
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../community/index.html">
  Community
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../api/index.html">
  API Reference
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://napari-hub.org">napari hub<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/napari/napari" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../start_index.html">
   Getting started
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../fundamentals/installation.html">
     How to install napari on your machine
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../fundamentals/getting_started.html">
     Getting started with napari
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../fundamentals/viewer.html">
     napari viewer tutorial
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/layers.html">
     Layers at a glance
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../index.html">
   napari tutorials
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="../segmentation/index.html">
     Segmentation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../tracking/index.html">
     Tracking
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="annotate_points.html">
     Annotating videos with napari
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Using Dask and napari to process &amp; view large datasets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../tracking/cell_tracking.html">
     Single cell tracking with napari
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../segmentation/annotate_segmentation.html">
     Annotating segmentation with text and bounding boxes
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../further-resources/napari-workshops.html">
   napari workshops
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../howtos/index.html">
   How-to guides
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../howtos/layers/index.html">
     Using layers
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="../../howtos/layers/image.html">
       Using the image layer
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../howtos/layers/labels.html">
       Using the labels layer
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../howtos/layers/points.html">
       Using the points layer
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../howtos/layers/shapes.html">
       Using the shapes layer
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../howtos/layers/surface.html">
       Using the surface layer
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../howtos/layers/tracks.html">
       Using the tracks layer
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../../howtos/layers/vectors.html">
       Using the vectors layer
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../howtos/connecting_events.html">
     Hooking up your own events
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../howtos/napari_imageJ.html">
     napari + ImageJ how-to guide
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../howtos/docker.html">
     Napari in Docker
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../howtos/perfmon.html">
     Performance monitoring
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../guides/index.html">
   In-depth explanations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/magicgui.html">
     Using
     <code class="docutils literal notranslate">
      <span class="pre">
       magicgui
      </span>
     </code>
     in napari
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/event_loop.html">
     An introduction to the event loop in napari
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/threading.html">
     Multithreading in napari
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/rendering-explanation.html">
     Rendering in napari
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/rendering.html">
     Asynchronous rendering
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/performance.html">
     napari performance
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/3D_interactivity.html">
     3D interactivity
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/events_reference.html">
     Events reference
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/contexts_expressions.html">
     Contexts and Expressions in napari
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../guides/preferences.html">
     Preferences
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../further-resources/glossary.html">
   Glossary
  </a>
 </li>
</ul>

  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#using-dask-delayed-to-load-images">
   Using
   <code class="docutils literal notranslate">
    <span class="pre">
     dask.delayed
    </span>
   </code>
   to load images
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#make-your-life-easier-with-dask-image">
   Make your life easier with
   <code class="docutils literal notranslate">
    <span class="pre">
     dask-image
    </span>
   </code>
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#side-note-regarding-higher-dimensional-datasets">
     <strong>
      Side note regarding higher-dimensional datasets
     </strong>
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#processing-data-with-dask-array-map-blocks">
   Processing data with
   <code class="docutils literal notranslate">
    <span class="pre">
     dask.array.map_blocks
    </span>
   </code>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#further-reading">
   Further reading
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="using-dask-and-napari-to-process-view-large-datasets">
<h1>Using Dask and napari to process &amp; view large datasets<a class="headerlink" href="#using-dask-and-napari-to-process-view-large-datasets" title="Permalink to this headline">¶</a></h1>
<p>Often in microscopy, multidimensional data is acquired and written to disk in many small files,
each of which contain a subset of one or more dimensions from the complete dataset.
For example, in a 5-dimensional experiment
(e.g. 3D z-stacks acquired for multiple channels at various moments over time),
each file on disk might be a 3D TIFF stack from a single channel at a single timepoint.
Data may also be stored in some proprietary format.
As the size of the dataset grows,
viewing arbitrary slices (in time, channel, z) of these datasets can become cumbersome.</p>
<p>Chunked file formats exist (such as <a class="reference external" href="https://support.hdfgroup.org/HDF5/">hdf5</a> and <a class="reference external" href="https://zarr.readthedocs.io/en/stable/">zarr</a>) that store data in a way that makes it easier to retrieve arbitrary subsets of the dataset, but they require either data duplication, or “committing” to a new file standard.</p>
<blockquote>
<div><p><strong>Note</strong>: This tutorial is not meant to promote a folder of TIFFs as a “good way” to store large datasets on disk;
but it is undoubtedly a common scenario in microscopy.
Chunked formats such as <code class="docutils literal notranslate"><span class="pre">hdf5</span></code> or <code class="docutils literal notranslate"><span class="pre">zarr</span></code> are superior in many ways,
but they do require the user to either duplicate their data
or go “all in” and delete the original data after conversion.
And while <code class="docutils literal notranslate"><span class="pre">napari</span></code> can easily handle something like a <code class="docutils literal notranslate"><span class="pre">zarr</span></code> store,
it can be a bit more limiting inasmuch as it requires programs that are capable of viewing it (i.e. you can’t necessarily just drag it into Fiji …)</p>
</div></blockquote>
<p>The first part of this tutorial demonstrates how to use <a class="reference external" href="https://docs.dask.org/en/latest/"><code class="docutils literal notranslate"><span class="pre">Dask</span></code></a>
and <a class="reference external" href="https://docs.dask.org/en/latest/delayed.html"><code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code></a>
(or <a class="reference external" href="https://github.com/dask/dask-image"><code class="docutils literal notranslate"><span class="pre">dask_image</span></code></a>) to feed <code class="docutils literal notranslate"><span class="pre">napari</span></code> image data “<a class="reference external" href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazily</a>”:
that is, the specific image file corresponding to the requested timepoint/channel
is only read from disk at the moment it is required
(based on the current position of the dimension sliders in <code class="docutils literal notranslate"><span class="pre">napari</span></code>).
Additionally, we will see that <em>any</em> function that takes a filepath
and returns a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array can be used to lazily read image data.
This can be useful if you have a proprietary format that is not immediately recognized by <code class="docutils literal notranslate"><span class="pre">napari</span></code>
(but for which you have at least some way of reading into a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array)</p>
<p>In some cases, data must be further processed prior to viewing,
such as a deskewing step for images acquired on a stage-scanning light sheet microscope.
Or perhaps you’d like to apply some basic image corrections or ratiometry prior to viewing.
The second part of this tutorial demonstrates the use of the <a class="reference external" href="https://docs.dask.org/en/latest/array-api.html#dask.array.map_blocks"><code class="docutils literal notranslate"><span class="pre">dask.array.map_blocks</span></code></a> function
to describe an arbitrary sequence of functions in a declarative manner
that will be performed <em>on demand</em> as you explore the data (i.e. move the sliders) in <code class="docutils literal notranslate"><span class="pre">napari</span></code>.</p>
<div class="section" id="using-dask-delayed-to-load-images">
<h2>Using <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> to load images<a class="headerlink" href="#using-dask-delayed-to-load-images" title="Permalink to this headline">¶</a></h2>
<p>If you have a function that can take a filename and return a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array,
such as <code class="docutils literal notranslate"><span class="pre">skimage.io.imread</span></code>,
you can create a “lazy” version of that function by calling <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code> on the function itself.
This <em>new</em> function, when handed a filename,
will not actually read the file until explicitly asked with the <code class="docutils literal notranslate"><span class="pre">compute()</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skimage.io</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">delayed</span>

<span class="n">lazy_imread</span> <span class="o">=</span> <span class="n">delayed</span><span class="p">(</span><span class="n">imread</span><span class="p">)</span>
<span class="n">reader</span> <span class="o">=</span> <span class="n">lazy_imread</span><span class="p">(</span><span class="s1">&#39;/path/to/file.tif&#39;</span><span class="p">)</span>  <span class="c1"># doesn&#39;t actually read the file</span>
<span class="n">array</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  <span class="c1"># *now* it reads.</span>
</pre></div>
</div>
<p>(If you have an unusual image format,
but you <em>do</em> have a python function that returns a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array,
simply substitute it for <code class="docutils literal notranslate"><span class="pre">skimage.io.imread</span></code> in the example above).</p>
<p>We can create a <a class="reference external" href="https://docs.dask.org/en/latest/array.html">Dask array</a> of delayed file-readers
for <em>all</em> of the files in our multidimensional experiment using the <code class="docutils literal notranslate"><span class="pre">dask.array.from_delayed</span></code> function
and a <a class="reference external" href="https://docs.python.org/3/library/glob.html"><code class="docutils literal notranslate"><span class="pre">glob</span></code></a> filename pattern
(<em>this example assumes that all files are of the same <code class="docutils literal notranslate"><span class="pre">shape</span></code> and <code class="docutils literal notranslate"><span class="pre">dtype</span></code>!</em>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">skimage.io</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="kn">from</span> <span class="nn">skimage.io.collection</span> <span class="kn">import</span> <span class="n">alphanumeric_key</span>
<span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">delayed</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>

<span class="n">filenames</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;/path/to/experiment/*.tif&quot;</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">alphanumeric_key</span><span class="p">)</span>
<span class="c1"># read the first file to get the shape and dtype</span>
<span class="c1"># ASSUMES THAT ALL FILES SHARE THE SAME SHAPE/TYPE</span>
<span class="n">sample</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">filenames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">lazy_imread</span> <span class="o">=</span> <span class="n">delayed</span><span class="p">(</span><span class="n">imread</span><span class="p">)</span>  <span class="c1"># lazy reader</span>
<span class="n">lazy_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">lazy_imread</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">]</span>
<span class="n">dask_arrays</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">da</span><span class="o">.</span><span class="n">from_delayed</span><span class="p">(</span><span class="n">delayed_reader</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sample</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">delayed_reader</span> <span class="ow">in</span> <span class="n">lazy_arrays</span>
<span class="p">]</span>
<span class="c1"># Stack into one large dask.array</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">dask_arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">stack</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># (nfiles, nz, ny, nx)</span>

<span class="c1"># in jupyter notebook the repr of a dask stack provides a useful visual:</span>
<span class="n">stack</span>
</pre></div>
</div>
<p><img alt="image: dask array html representation" src="../../_images/dask_repr.png" /></p>
<p><em>No data has been read from disk yet!</em></p>
<p><code class="docutils literal notranslate"><span class="pre">napari</span></code> is capable of consuming Dask arrays,
so you can simply call <code class="docutils literal notranslate"><span class="pre">napari.view_image</span></code> on this <code class="docutils literal notranslate"><span class="pre">stack</span></code> and behind the scenes,
Dask will take care of reading the data from disk
and handing a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array to <code class="docutils literal notranslate"><span class="pre">napari</span></code> each time a new timepoint or channel is requested.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">napari</span>

<span class="c1"># specify contrast_limits and multiscale=False with big data</span>
<span class="c1"># to avoid unnecessary computations</span>
<span class="n">napari</span><span class="o">.</span><span class="n">view_image</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">contrast_limits</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2000</span><span class="p">],</span> <span class="n">multiscale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Note: providing the</em> <code class="docutils literal notranslate"><span class="pre">contrast_limits</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">multiscale</span></code> <em>arguments prevents</em> <code class="docutils literal notranslate"><span class="pre">napari</span></code> <em>from trying to calculate the data min/max, which can take an extremely long time with big data.
See <a class="reference external" href="https://github.com/napari/napari/issues/736">napari issue #736</a> for further discussion.</em></p>
</div>
<div class="section" id="make-your-life-easier-with-dask-image">
<h2>Make your life easier with <code class="docutils literal notranslate"><span class="pre">dask-image</span></code><a class="headerlink" href="#make-your-life-easier-with-dask-image" title="Permalink to this headline">¶</a></h2>
<p>This pattern for creating a <code class="docutils literal notranslate"><span class="pre">dask.array</span></code> from image data
has been previously described in an <a class="reference external" href="https://blog.dask.org/2019/06/20/load-image-data">excellent blog post</a> by John Kirkham.
It is a common-enough pattern that John created a useful library (<a class="reference external" href="https://github.com/dask/dask-image"><code class="docutils literal notranslate"><span class="pre">dask-image</span></code></a>)
that does all this for you,
provided your image format can be read by the <a class="reference external" href="https://github.com/soft-matter/pims"><code class="docutils literal notranslate"><span class="pre">pims</span></code></a> (Python Image Sequence) reader
(if not, see note above about providing your own reader function with <code class="docutils literal notranslate"><span class="pre">dask.delayed</span></code>).</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">dask-image</span></code>, <em>all</em> of the above code can be simplified to 5 lines:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">napari</span>
<span class="kn">from</span> <span class="nn">dask_image.imread</span> <span class="kn">import</span> <span class="n">imread</span>

<span class="n">stack</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s2">&quot;/path/to/experiment/*.tif&quot;</span><span class="p">)</span>
<span class="n">napari</span><span class="o">.</span><span class="n">view_image</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">contrast_limits</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2000</span><span class="p">],</span> <span class="n">multiscale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="image: mCherry-H2B showing chromosome separation during mitosis. Collected on a lattice light sheet microscope" src="../../_images/dask1.gif" /></p>
<div class="section" id="side-note-regarding-higher-dimensional-datasets">
<h3><strong>Side note regarding higher-dimensional datasets</strong><a class="headerlink" href="#side-note-regarding-higher-dimensional-datasets" title="Permalink to this headline">¶</a></h3>
<p>In the above example, it would be quite common to have a 5+ dimensional dataset
(e.g. different timepoints <em>and</em> channels represented among the 3D TIFF files in a folder).
A standard approach to deal with that sort of thing in <code class="docutils literal notranslate"><span class="pre">numpy</span></code> would be to <code class="docutils literal notranslate"><span class="pre">reshape</span></code> the array after instantiation.
With Dask, reshaping arrays can <em>sometimes</em> lead to unexpected read events if you’re not careful.</p>
<p>For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask_image.imread</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s1">&#39;/path/to/experiment/*.tif&#39;</span><span class="p">)</span>
<span class="n">stack</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># -&gt; something like (1200, 64, 256, 280)</span>
<span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  <span class="c1"># incurs a single file read</span>

<span class="c1"># if there were two channels in that folder you might try to do this:</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">280</span><span class="p">)</span>
<span class="c1"># but now trying to read just the first timepoint in the first channel:</span>
<span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  <span class="c1"># incurs 600 read events!</span>
</pre></div>
</div>
<p>We will update this post as best-practices emerge,
but one possible solution to this is to avoid reshaping
Dask arrays altogether, by constructing multiple Dask arrays using <code class="docutils literal notranslate"><span class="pre">dask-image</span></code>, and then using
<code class="docutils literal notranslate"><span class="pre">da.stack</span></code> to combine them:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dask_image.imread</span> <span class="kn">import</span> <span class="n">imread</span>
<span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>

<span class="c1"># # instead of this</span>
<span class="c1"># stack = imread(&#39;/path/to/experiment/*.tif&#39;)</span>
<span class="c1"># stack = stack.reshape(2, 600, 64, 256, 280)</span>
<span class="c1"># stack[0, 0].compute()  # incurs 600 read events!</span>

<span class="c1"># do something like this:</span>
<span class="n">file_pattern</span> <span class="o">=</span> <span class="s2">&quot;/path/to/experiment/*ch</span><span class="si">{}</span><span class="s2">*.tif&quot;</span>
<span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">imread</span><span class="p">(</span><span class="n">file_pattern</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchannels</span><span class="p">)]</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
<span class="n">stack</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># (2, 600, 64, 256, 280)</span>
<span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>  <span class="c1"># incurs a single file read</span>

</pre></div>
</div>
</div>
</div>
<div class="section" id="processing-data-with-dask-array-map-blocks">
<h2>Processing data with <code class="docutils literal notranslate"><span class="pre">dask.array.map_blocks</span></code><a class="headerlink" href="#processing-data-with-dask-array-map-blocks" title="Permalink to this headline">¶</a></h2>
<p>As previously mentioned,
sometimes it is desirable to process data prior to viewing.
We’ll take as an example
a series of TIFF files acquired on a lattice-light-sheet microscope.
A typical workflow might be to deskew, deconvolve, and perhaps crop
or apply some channel registration prior to viewing.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">dask.array.map_blocks</span></code> we can apply any function that accepts a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array
and returns a modified array to all the images in our <code class="docutils literal notranslate"><span class="pre">dask.array</span></code>.
It will be evaluated lazily, when requested (in this case, by <code class="docutils literal notranslate"><span class="pre">napari</span></code>);
we do not have to wait for it to process the entire dataset.</p>
<p>Here is an example of a script that will take a folder of raw tiff files,
and lazily read, deskew, deconvolve, crop,
and display them, <em>on demand</em> as you move the <code class="docutils literal notranslate"><span class="pre">napari</span></code> dimensions sliders around.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">napari</span>
<span class="kn">import</span> <span class="nn">pycudadecon</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">io</span>
<span class="kn">from</span> <span class="nn">dask_image.imread</span> <span class="kn">import</span> <span class="n">imread</span>

<span class="c1"># load stacks with dask_image, and psf with skimage</span>
<span class="n">stack</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s2">&quot;/path/to/experiment/*.tif&quot;</span><span class="p">)</span>
<span class="n">psf</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s2">&quot;/path/to/psf.tif&quot;</span><span class="p">)</span>

<span class="c1"># prepare some functions that accept a numpy array</span>
<span class="c1"># and return a processed array</span>

<span class="k">def</span> <span class="nf">last3dims</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="c1"># this is just a wrapper because the pycudadecon function</span>
    <span class="c1"># expects ndims==3 but our blocks will have ndim==4</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="c1"># simple cropping function</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">10</span><span class="p">:</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="p">:</span><span class="mi">500</span><span class="p">]</span>

<span class="c1"># https://docs.python.org/3.8/library/functools.html#functools.partial</span>
<span class="n">deskew</span> <span class="o">=</span> <span class="n">last3dims</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">pycudadecon</span><span class="o">.</span><span class="n">deskew_gpu</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mf">31.5</span><span class="p">))</span>
<span class="n">deconv</span> <span class="o">=</span> <span class="n">last3dims</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">pycudadecon</span><span class="o">.</span><span class="n">decon</span><span class="p">,</span> <span class="n">psf</span><span class="o">=</span><span class="n">psf</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="c1"># note: this is done in two steps just as an example...</span>
<span class="c1"># in reality pycudadecon.decon also has a deskew argument</span>

<span class="c1"># map and chain those functions across all dask blocks</span>
<span class="n">deskewed</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">deskew</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint16&quot;</span><span class="p">)</span>
<span class="n">deconvolved</span> <span class="o">=</span> <span class="n">deskewed</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">deconv</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="n">cropped</span> <span class="o">=</span> <span class="n">deconvolved</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">crop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

<span class="c1"># put the resulting dask array into napari.</span>
<span class="c1"># (don&#39;t forget the contrast limits and multiscale==False !)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">napari</span><span class="o">.</span><span class="n">view_image</span><span class="p">(</span>
    <span class="n">cropped</span><span class="p">,</span>
    <span class="n">contrast_limits</span><span class="o">=</span><span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">1500</span><span class="p">],</span>
    <span class="n">multiscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ndisplay</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">napari</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Of course, the GUI isn’t as responsive as it would be if you had processed the data up front
and loaded the results into RAM and viewed them in <code class="docutils literal notranslate"><span class="pre">napari</span></code> (it’s doing a lot of work after all!),
but it’s surprisingly usable,
and allows you to preview the result of a relatively complex processing pipeline <em>on-the-fly</em>,
for arbitrary timepoints/channels, while storing <em>only</em> the raw data on disk.</p>
<p><img alt="image: same dataset, demonstrating on-the-fly read → deskew → deconvolve → crop" src="../../_images/dask2.gif" /></p>
<p>This workflow is very much patterned after <a class="reference external" href="https://blog.dask.org/2019/08/09/image-itk">another great post by John Kirkham, Matthew Rocklin, and Matthew McCormick</a>
that describes a similar image processing pipeline using <a class="reference external" href="https://itk.org/">ITK</a>.
<code class="docutils literal notranslate"><span class="pre">napari</span></code> simply sits at the end of this lazy processing chain,
ready to show you the result on demand!</p>
</div>
<div class="section" id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.dask.org/en/latest/delayed.html">Documentation on dask.delayed</a></p></li>
<li><p><a class="reference external" href="https://blog.dask.org/2019/06/20/load-image-data">Dask working notes on dask-image</a></p></li>
<li><p><a class="reference external" href="https://blog.dask.org/2019/08/09/image-itk">Dask working notes on image processing with <code class="docutils literal notranslate"><span class="pre">dask.array.map_blocks</span></code></a></p></li>
</ul>
</div>
</div>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="annotate_points.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Annotating videos with napari</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../tracking/cell_tracking.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Single cell tracking with napari</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
    <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, The napari team.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.4.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>